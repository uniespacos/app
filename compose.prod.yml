services:
    web:
        container_name: web-production
        image: ghcr.io/${GHCR_REPO_WEB}/web:${IMAGE_TAG:-latest} # Using pre-built image from GHCR
        restart: unless-stopped
        env_file:
            - stack.env
        ports:
            - "80:80"
        volumes:
            - uniespacos-storage-production:/var/www/storage:ro
            - uniespacos-public-assets:/var/www/public/build:ro
            - uniespacos-public-production:/var/www/public:ro
            - ./docker/production/nginx/prod.http-redirect.conf:/etc/nginx/conf.d/default.conf:ro
        networks:
            - uniespacos-production
        depends_on:
            app:
                condition: service_healthy
    app:
        container_name: app-production
        image: ghcr.io/${GHCR_REPO_APP}/app:${IMAGE_TAG:-latest} # Using pre-built image from GHCR
        restart: unless-stopped
        volumes:
            - uniespacos-public-assets:/var/www/public/build
            - uniespacos-storage-production:/var/www/storage
            - uniespacos-public-production:/var/www/public
        env_file:
            - stack.env
        networks:
            - uniespacos-production
        healthcheck:
            test: [ "CMD-SHELL", "php-fpm-healthcheck || exit 1" ]
            interval: 10s
            timeout: 5s
            retries: 3
        depends_on:
            postgres:
                condition: service_healthy
    queue-worker:
        container_name: queue-worker-production
        image: ghcr.io/${GHCR_REPO_APP}/app:${IMAGE_TAG:-latest} # Using pre-built image from GHCR
        restart: unless-stopped
        command: php artisan queue:work --verbose --tries=3 --timeout=90
        volumes:
            - uniespacos-storage-production:/var/www/storage
        env_file:
            - stack.env
        networks:
            - uniespacos-production
        depends_on:
            - postgres
            - app

    postgres:
        container_name: postgres-production
        image: postgres:16
        restart: unless-stopped
        user: postgres
        ports:
            - "${DB_PORT:-5432}:5432"
        env_file:
            - stack.env
        environment:
            - PGPASSWORD=${DB_PASSWORD}
            - POSTGRES_DB=${DB_DATABASE}
            - POSTGRES_USER=${DB_USERNAME}
            - POSTGRES_PASSWORD=${DB_PASSWORD}
        volumes:
            - 'postgres-data-production:/var/lib/postgresql/data'
        networks:
            - uniespacos-production
        healthcheck:
            test: [ "CMD-SHELL", "pg_isready -U ${DB_USERNAME} -d ${DB_DATABASE}" ]
            interval: 10s
            timeout: 5s
            retries: 5

    watchtower:
        container_name: watchtower-production
        image: nickfedor/watchtower:latest
        restart: unless-stopped
        command: --cleanup --interval 300
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
        env_file:
            - stack.env
        environment:
            # Configuração para logar no GitHub Registry (Necessário se for privado)
            - REPO_USER=${GITHUB_USER}
            - REPO_PASS=${GITHUB_TOKEN} # Seu Token gerado no GitHub
            - WATCHTOWER_POLL_INTERVAL=60 # Verifica a cada 60 segundos
            - WATCHTOWER_CLEANUP=true # Remove imagens velhas para não encher o disco
            - WATCHTOWER_INCLUDE_RESTARTING=true
networks:
    uniespacos-production:


volumes:
    postgres-data-production:
    uniespacos-storage-production:
    uniespacos-public-assets:
    uniespacos-public-production:
