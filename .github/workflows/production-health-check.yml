name: Production Setup Validation

on:
  workflow_dispatch:
  pull_request:
    branches: ["main", "develop"]
  push:
    branches: ["main"]

jobs:
  validate-docker-prod:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Production .env for CI
        run: |
          if [ -f .env.prod ]; then cp .env.prod .env; else cp .env.example .env; fi
          sed -i 's|DB_HOST=postgres|DB_HOST=postgres|' .env
          sed -i 's|DB_PASSWORD=.*|DB_PASSWORD=ci_testing_pass|' .env
          sed -i 's|APP_ENV=.*|APP_ENV=production|' .env
          # NOTE: Dummy APP_KEY for CI testing only; never use this key in real production environments.
          sed -i 's|APP_KEY=.*|APP_KEY=base64:2fl+Ktvkfl+Fuz4Qp/yWci8eGBzDM/fciRCvmbL/zqM=|' .env
          sed -i 's|PUSHER_APP_KEY=.*|PUSHER_APP_KEY=dummy_key|' .env
          sed -i 's|PUSHER_APP_CLUSTER=.*|PUSHER_APP_CLUSTER="mt1"|' .env

      - name: Generate SSL & Debug Context
        run: |
          mkdir -p docker/production/nginx/ssl/

          echo "üîê Gerando Certificado..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout docker/production/nginx/ssl/uesb2025privkey.pem \
            -out docker/production/nginx/ssl/uesb2025fullchain.pem \
            -subj "/C=BR/ST=Bahia/L=Vitoria/O=UESB/CN=localhost"

          echo "üìÇ Verificando arquivos gerados:"
          ls -lh docker/production/nginx/ssl/

          # TESTE DE SEGURAN√áA: Falha se o arquivo estiver vazio
          if [ ! -s docker/production/nginx/ssl/uesb2025fullchain.pem ]; then
            echo "‚ùå ERRO: O certificado foi criado vazio!"
            exit 1
          fi

      - name: Build and Start Containers
        run: docker compose -f compose.prod.yml up -d --build

      - name: Wait for Services (Dynamic Check)
        run: |
          echo "‚è≥ Aguardando servi√ßos..."

          # Pega os IDs reais dos containers usando o compose.
          # Isso resolve o erro "No such object" pois n√£o adivinhamos o nome.
          PHP_CONTAINER=$(docker compose -f compose.prod.yml ps -q php-fpm)
          DB_CONTAINER=$(docker compose -f compose.prod.yml ps -q postgres)

          echo "PHP Container ID: $PHP_CONTAINER"
          echo "DB Container ID: $DB_CONTAINER"

          # Aguarda PHP
          timeout 60s bash -c "until [ \"\$(docker inspect -f '{{.State.Health.Status}}' $PHP_CONTAINER)\" == \"healthy\" ]; do sleep 2; done" || (echo "‚ùå PHP Healthcheck Timeout" && exit 1)

          # Aguarda Postgres
          timeout 60s bash -c "until [ \"\$(docker inspect -f '{{.State.Health.Status}}' $DB_CONTAINER)\" == \"healthy\" ]; do sleep 2; done" || (echo "‚ùå DB Healthcheck Timeout" && exit 1)

      - name: Verify Nginx (HTTP Check)
        run: |
          WEB_CONTAINER=$(docker compose -f compose.prod.yml ps -q web)
          if [ "$(docker inspect -f '{{.State.Running}}' $WEB_CONTAINER)" != "true" ]; then 
             echo "‚ùå Nginx n√£o est√° rodando!"; 
             docker logs $WEB_CONTAINER
             exit 1 
          fi

          # Tenta acessar. Se o SSL estiver ruim, o curl vai reclamar de conex√£o fechada ou erro de protocolo.
          # Usamos --insecure (-k) pois o certificado √© auto-assinado, mas queremos ver se responde.
          sleep 5
          curl -v -k --fail https://localhost || curl -v --fail http://localhost || echo "‚ö†Ô∏è Curl falhou, checar logs"

      - name: Show Logs on Failure
        if: failure()
        run: docker compose -f compose.prod.yml logs
