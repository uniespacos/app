name: CI/CD Pipeline Completa

on:
  push:
    branches:
      - "main"
      - "development"
  pull_request:
    branches:
      - development
      - main
  # Permite rodar manualmente na aba Actions (√≥timo para rollback ou testes)
  workflow_dispatch:

jobs:
  quality-check:
    name: üîç Lint & Static Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.4"
      - name: Install Dependencies
        run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist
      - name: Run Pint (Code Style)
        run: vendor/bin/pint --test

  # ETAPA 2: Testes de Unidade e Integra√ß√£o
  tests:
    name: üß™ PHPUnit Tests
    needs: quality-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build and Run Services (Postgres, Workspace)
        run: docker compose -f docker-compose.test.yml up --build -d
      - name: Wait for database to be ready
        run: |
          echo "Waiting for postgres to be ready..."
          for i in $(seq 1 30); do
            docker compose -f docker-compose.test.yml exec postgres pg_isready -U uniespacos -d uniespacos
            if [ $? -eq 0 ]; then
              echo "Postgres is ready!"
              break
            fi
            echo "Waiting for postgres... ($i/30)"
            sleep 2
          done
          if [ $? -ne 0 ]; then
            echo "Postgres did not become ready in time."
            exit 1
          fi
      - name: Install PHP Dependencies
        run: docker compose -f docker-compose.test.yml exec -T workspace composer install --no-interaction --no-progress --prefer-dist
      - name: Run Migrations and Seed
        run: docker compose -f docker-compose.test.yml exec -T workspace php artisan migrate --seed --force
      - name: Run Tests
        run: docker compose -f docker-compose.test.yml exec -T workspace php artisan test
      - name: Stop Services
        if: always()
        run: docker compose -f docker-compose.test.yml down


  # ETAPA 3: Smoke Test da Infra (Docker)
  # Usa a l√≥gica corrigida que criamos anteriormente
  infrastructure-test:
    name: üèóÔ∏è Docker Build Check
    needs: quality-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Create Production .env for CI
        run: |
          if [ -f .env.prod ]; then cp .env.prod .env; else cp .env.example .env; fi
          # Adapta√ß√µes para o ambiente CI
          sed -i 's|DB_HOST=postgres|DB_HOST=postgres|' .env
          sed -i 's|DB_PASSWORD=.*|DB_PASSWORD=ci_testing_pass|' .env
          sed -i 's|APP_KEY=.*|APP_KEY=base64:2fl+Ktvkfl+Fuz4Qp/yWci8eGBzDM/fciRCvmbL/zqM=|' .env

      - name: Create stack.env for Docker Compose
        run: |
          echo "DB_HOST=postgres" >> stack.env
          echo "DB_PORT=5432" >> stack.env
          echo "DB_DATABASE=uniespacos" >> stack.env
          echo "DB_USERNAME=uniespacos" >> stack.env
          echo "DB_PASSWORD=ci_testing_pass" >> stack.env

          echo "GHCR_REPO_APP=${{ github.repository }}" >> stack.env
          echo "GHCR_REPO_WEB=${{ github.repository }}" >> stack.env

          echo "GITHUB_USER=ci_user" >> stack.env
          echo "GITHUB_TOKEN=ci_token" >> stack.env

          echo "WEB_PORT=80" >> stack.env
          echo "WEB_PORT_SSL=443" >> stack.env

      - name: Generate SSL for Test
        run: |
          mkdir -p docker/production/nginx/ssl/
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout docker/production/nginx/ssl/uesb2025privkey.pem \
            -out docker/production/nginx/ssl/uesb2025fullchain.pem \
            -subj "/C=BR/ST=Bahia/L=Vitoria/O=UESB/CN=localhost"

      - name: Build Containers
        run: docker compose -f compose.prod.yml up -d postgres web

  # ETAPA 4: Deploy em Produ√ß√£o
  deploy-production:
    name: üöÄ Deploy to VPS
    # S√≥ roda se TUDO anterior passar. Seguran√ßa m√°xima.
    needs: [tests, infrastructure-test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' # S√≥ roda na branch main

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script_stop: true # Para se qualquer comando falhar
          # Ajuste o caminho '/var/www/uniespacos' para onde seu projeto est√° na VPS
          script: |
            echo "üìç Iniciando Deploy..."
            cd /var/www/uniespacos

            echo "Maintenance Mode ON..."
            # O '|| true' impede que o deploy falhe se o container n√£o estiver rodando ainda
            docker compose -f compose.prod.yml exec -T web php artisan down || true

            echo "üì• Atualizando c√≥digo..."
            git pull origin main

            echo "üê≥ Reconstruindo Containers..."
            docker compose -f compose.prod.yml up -d --remove-orphans

            echo "‚è≥ Aguardando Banco de Dados..."
            sleep 10

            echo "üîÑ Rodando Migrations..."
            docker compose -f compose.prod.yml exec -T web php artisan migrate --force

            echo "üßπ Otimizando Laravel..."
            docker compose -f compose.prod.yml exec -T web php artisan optimize
            docker compose -f compose.prod.yml exec -T web php artisan view:cache
            docker compose -f compose.prod.yml exec -T web php artisan config:cache

            # Se voc√™ usa filas, √© CR√çTICO reiniciar o worker para pegar o c√≥digo novo
            echo "üîÑ Reiniciando Filas..."
            docker compose -f compose.prod.yml restart queue-worker

            echo "‚úÖ Maintenance Mode OFF..."
            docker compose -f compose.prod.yml exec -T web php artisan up

            echo "üöÄ Deploy Conclu√≠do com Sucesso!"
